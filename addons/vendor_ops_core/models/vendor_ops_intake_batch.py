# -*- coding: utf-8 -*-
# Vendor Ops Intake Batch model - merged from vendor_ops_intake_notion
# Version: 19.0.2.0.0

import json
import logging
import re
from odoo import models, fields, api
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)


class VendorOpsIntakeBatch(models.Model):
    _name = 'vendor.ops.intake.batch'
    _description = 'Vendor Ops Intake Batch'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'create_date desc'

    _sql_constraints = [
        ('unique_tenant_store_month',
         'UNIQUE(tenant_id, store_code, effective_month)',
         'A batch already exists for this tenant, store, and month.'),
    ]

    @api.constrains('effective_month')
    def _check_effective_month_format(self):
        """Validate effective_month format."""
        for record in self:
            if record.effective_month:
                if not re.match(r'^\d{4}-\d{2}$', record.effective_month):
                    raise UserError('Effective Month must be in format YYYY-MM (e.g., 2026-01)')

    # Core fields
    name = fields.Char(
        string='Batch Name',
        required=True,
        readonly=True,
        index=True,
        tracking=True,
        help='Auto-generated: {tenant_code}/{store_code}/{effective_month}'
    )

    tenant_id = fields.Many2one(
        'vendor.ops.tenant',
        string='Tenant',
        required=True,
        tracking=True,
        ondelete='cascade'
    )
    tenant_code = fields.Char(
        string='Tenant Code',
        related='tenant_id.code',
        store=True,
        readonly=True,
        tracking=True
    )

    store_code = fields.Char(
        string='Store Code',
        required=True,
        tracking=True
    )
    effective_month = fields.Char(
        string='Effective Month',
        required=True,
        tracking=True,
        help='Format: YYYY-MM (e.g., 2026-01)'
    )

    # Bridge fields
    bridge_batch_id = fields.Char(
        string='Bridge Batch ID',
        readonly=True,
        tracking=True,
        copy=False,
        help='UUID generated by Bridge system'
    )
    client_record_url = fields.Char(
        string='Client Record URL',
        readonly=True,
        tracking=True,
        help='Notion URL for client intake record (send to client)'
    )
    notion_pack_url = fields.Char(
        string='Notion Pack URL',
        readonly=True,
        tracking=True,
        help='Main link to Notion pack page'
    )
    notion_batch_page_id = fields.Char(
        string='Notion Batch Page ID',
        readonly=True,
        tracking=True,
        help='Notion page ID in Intake-Batches database'
    )
    notion_internal_page_id = fields.Char(
        string='Notion Internal Page ID',
        readonly=True,
        tracking=True,
        help='Notion page ID in Internal Intake-Batches DB'
    )
    notion_page_urls = fields.Text(
        string='Notion Page URLs',
        readonly=True,
        help='JSON text containing URLs for profile/menu/supplier/bom/payroll pages'
    )
    notion_pack_databases_json = fields.Text(
        string='Pack Databases JSON',
        readonly=True,
        tracking=True,
        help='JSON containing pack sub-database IDs (Profile/Menu/BOM/Payroll/SupplierItems). Required for Pull.'
    )
    notion_pack_meta_database_id = fields.Char(
        string='Pack Meta Database ID',
        readonly=True,
        tracking=True,
        help='Notion database ID for PackMeta'
    )
    notion_pack_page_id = fields.Char(
        string='Pack Page ID',
        readonly=True,
        tracking=True,
        help='Notion page ID for the Pack page'
    )

    # Status fields
    status = fields.Selection([
        ('draft', 'Draft'),
        ('collecting', 'Collecting'),
        ('pulled', 'Pulled'),
        ('review', 'Review'),
        ('push_ready', 'Push Ready'),
    ], string='Status', default='draft', tracking=True)

    # Pull tracking fields (merged from vendor_intake_notion)
    last_pull_at = fields.Datetime(
        string='Last Pull At',
        readonly=True,
        tracking=True
    )
    last_pull_summary = fields.Text(
        string='Last Pull Summary',
        readonly=True,
        help='JSON text containing pull results (counts per entry_type)'
    )
    last_error = fields.Text(
        string='Last Error',
        readonly=True,
        tracking=True,
        help='Last error message from Bridge API (includes traceId if available)'
    )
    bridge_trace_id = fields.Char(
        string='Bridge Trace ID',
        readonly=True,
        tracking=True,
        help='Last traceId/request_id from Bridge API for debugging'
    )

    note = fields.Text(string='Note')

    @api.model
    def _generate_batch_name(self, tenant_code, store_code, effective_month, tenant_id=None):
        """Generate batch name: {tenant_code}/{store_code}/{effective_month}"""
        # Use tenant_code if available, otherwise fallback to tenant_id
        if tenant_code:
            return f"{tenant_code}/{store_code}/{effective_month}"
        elif tenant_id:
            return f"TID-{tenant_id}/{store_code}/{effective_month}"
        else:
            return f"UNKNOWN/{store_code}/{effective_month}"

    @api.model_create_multi
    def create(self, vals_list):
        """Override create to auto-generate name before creation"""
        for vals in vals_list:
            # Generate name if not provided
            if not vals.get('name'):
                tenant_id = vals.get('tenant_id')
                store_code = vals.get('store_code', '')
                effective_month = vals.get('effective_month', '')

                # Get tenant_code
                tenant_code = None
                if tenant_id:
                    tenant = self.env['vendor.ops.tenant'].browse(tenant_id)
                    if tenant.exists():
                        tenant_code = tenant.code

                vals['name'] = self._generate_batch_name(
                    tenant_code=tenant_code,
                    store_code=store_code,
                    effective_month=effective_month,
                    tenant_id=tenant_id
                )

        return super().create(vals_list)

    # ========== URL Actions ==========

    def action_open_client_url(self):
        """Open client record URL in new window."""
        self.ensure_one()
        if not self.client_record_url:
            raise UserError('Client Record URL is not available.')
        return {
            'type': 'ir.actions.act_url',
            'url': self.client_record_url,
            'target': 'new',
        }

    def action_open_pack_url(self):
        """Open Notion pack URL in new window."""
        self.ensure_one()
        if not self.notion_pack_url:
            raise UserError('Notion Pack URL is not available.')
        return {
            'type': 'ir.actions.act_url',
            'url': self.notion_pack_url,
            'target': 'new',
        }

    def action_copy_client_url(self):
        """Return client URL for clipboard (via JS)."""
        self.ensure_one()
        if not self.client_record_url:
            raise UserError('Client Record URL is not available.')
        # Return notification with URL - actual clipboard handled by frontend
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Client URL',
                'message': f'URL: {self.client_record_url}',
                'type': 'info',
                'sticky': True,
            }
        }

    # ========== Generate Pack Action ==========

    def action_generate_pack(self):
        """Generate Notion pack via Bridge API."""
        self.ensure_one()

        if not self.bridge_batch_id:
            raise UserError('Bridge Batch ID not found. Please create the batch first.')

        try:
            from ..services.bridge_client import BridgeClient
            bridge = BridgeClient(self.env)

            _logger.info(f"Generating pack for batch {self.bridge_batch_id}")

            # Call Bridge API
            response = bridge.generate_pack(
                batch_id=self.bridge_batch_id
            )

            # Log response
            _logger.info(f"Generate pack response: {self._safe_json(response)[:500]}")

            # Handle errors
            if not isinstance(response, dict):
                error_msg = f"Unexpected response type: {type(response).__name__}"
                self._write_error(error_msg)
                raise UserError(error_msg)

            if not response.get('ok', False):
                error_msg = response.get('message', response.get('error', 'Unknown error'))
                trace_id = response.get('traceId') or response.get('trace_id')
                self._write_error(error_msg, trace_id)
                raise UserError(f"Bridge API Error: {error_msg}")

            # Extract pack URL and table IDs
            pack_url = response.get('pack_url') or response.get('notion_pack_url')
            table_ids = response.get('table_ids', {})

            # Update batch record
            update_vals = {
                'last_error': False,
            }
            if pack_url:
                update_vals['notion_pack_url'] = pack_url
            if table_ids:
                update_vals['notion_page_urls'] = json.dumps(table_ids, ensure_ascii=False)

            self.write(update_vals)

            self.message_post(
                body=f"Pack generated successfully. URL: {pack_url or 'N/A'}",
                subject='Pack Generated'
            )

            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Pack Generated',
                    'message': 'Notion pack generated successfully.',
                    'type': 'success',
                }
            }

        except UserError:
            raise
        except Exception as e:
            error_msg = f"Failed to generate pack: {str(e)}"
            self._write_error(error_msg)
            _logger.exception(f"Error generating pack for batch {self.id}")
            raise UserError(error_msg)

    # ========== Pull from Notion Action ==========

    def _ensure_pack_databases(self):
        """Ensure notion_pack_databases_json is populated.

        If missing, fetch from Bridge API via get_batch_info.
        Returns True if pack_databases is available (either existing or fetched).
        """
        if self.notion_pack_databases_json:
            return True

        if not self.bridge_batch_id:
            return False

        try:
            from ..services.bridge_client import BridgeClient
            bridge = BridgeClient(self.env)

            _logger.info(f"Fetching pack_databases from Bridge for batch {self.bridge_batch_id}")

            response = bridge.get_batch_info(self.bridge_batch_id)

            if not response.get('ok', False):
                _logger.warning(f"Failed to fetch batch info: {response.get('error', 'Unknown error')}")
                return False

            pack_databases = response.get('pack_databases')
            if pack_databases:
                # Serialize to JSON string
                if isinstance(pack_databases, dict):
                    pack_databases_json = json.dumps(pack_databases, ensure_ascii=False)
                elif isinstance(pack_databases, str):
                    pack_databases_json = pack_databases
                else:
                    pack_databases_json = json.dumps(pack_databases, ensure_ascii=False, default=str)

                # Update local record
                update_vals = {
                    'notion_pack_databases_json': pack_databases_json,
                }
                # Also update other fields if missing
                if not self.notion_pack_page_id and response.get('notion_pack_page_id'):
                    update_vals['notion_pack_page_id'] = response['notion_pack_page_id']
                if not self.notion_pack_meta_database_id and response.get('meta_database_id'):
                    update_vals['notion_pack_meta_database_id'] = response['meta_database_id']
                if not self.notion_pack_url and response.get('notion_pack_url'):
                    update_vals['notion_pack_url'] = response['notion_pack_url']

                self.write(update_vals)
                self.message_post(
                    body=f"Pack databases fetched from Bridge: {pack_databases_json[:200]}...",
                    subject='Pack Databases Updated',
                    message_type='notification'
                )
                return True
            else:
                _logger.warning(f"No pack_databases in Bridge response for batch {self.bridge_batch_id}")
                return False

        except Exception as e:
            _logger.exception(f"Error fetching pack_databases for batch {self.id}")
            return False

    def action_pull_from_notion(self):
        """Pull data from Notion via Bridge API."""
        self.ensure_one()

        if not self.bridge_batch_id:
            raise UserError('Bridge Batch ID not found. Please create the batch first.')

        try:
            from ..services.bridge_client import BridgeClient
            bridge = BridgeClient(self.env)

            # Ensure pack_databases is available (fetch from Bridge if missing)
            if not self.notion_pack_databases_json:
                _logger.info(f"notion_pack_databases_json missing, attempting to fetch from Bridge...")
                self._ensure_pack_databases()

            # Log request
            pull_params = {
                'tenant_code': self.tenant_code,
                'batch_id': self.bridge_batch_id,
                'has_pack_databases': bool(self.notion_pack_databases_json),
            }
            _logger.info(f"Bridge Pull: Request params: {json.dumps(pull_params, ensure_ascii=False)}")

            # Call Bridge API (pull_all for comprehensive pull)
            response = bridge.pull_all(
                tenant_code=self.tenant_code,
                batch_id=self.bridge_batch_id
            )

            # Log response structure
            response_preview = self._safe_json(response)[:1000]
            _logger.info(f"Bridge Pull: Response preview: {response_preview}")

            # Validate response type
            if not isinstance(response, dict):
                error_msg = f"Unexpected response type: {type(response).__name__}"
                self._write_error(error_msg)
                raise UserError(error_msg)

            # Check for error fields
            if 'statusCode' in response and response['statusCode'] >= 400:
                error_msg = response.get('message', 'Unknown error')
                trace_id = response.get('traceId') or response.get('trace_id')
                self._write_error(f"HTTP {response['statusCode']}: {error_msg}", trace_id)
                raise UserError(f"Bridge API Error ({response['statusCode']}): {error_msg}")

            # Check ok flag
            if not response.get('ok', False):
                error_msg = response.get('error', response.get('message', 'Unknown error'))
                trace_id = response.get('traceId') or response.get('trace_id') or response.get('request_id')
                self._write_error(error_msg, trace_id)
                raise UserError(f"Bridge API Error: {error_msg}")

            # Extract counts and trace info
            # Bridge API returns records_count (total) and _trace.databases_queried (details)
            counts = response.get('counts') or response.get('first', {}).get('counts') or {}

            # If no counts dict, build from _trace.databases_queried
            if not counts:
                trace_data = response.get('_trace', {})
                databases_queried = trace_data.get('databases_queried', [])
                for db_info in databases_queried:
                    db_key = db_info.get('database_key', 'unknown')
                    row_count = db_info.get('row_count', 0)
                    counts[db_key] = row_count

            trace_id_raw = (response.get('_trace', {}).get('trace_id') or
                           response.get('request_id') or
                           response.get('trace_id') or
                           response.get('traceId'))

            # Ensure trace_id is string (handle dict case)
            if trace_id_raw:
                if isinstance(trace_id_raw, dict):
                    trace_id = json.dumps(trace_id_raw, ensure_ascii=False, default=str)
                elif not isinstance(trace_id_raw, str):
                    trace_id = str(trace_id_raw)
                else:
                    trace_id = trace_id_raw
            else:
                trace_id = False

            # Calculate total - use records_count if available, otherwise sum counts
            total_imported = response.get('records_count') or sum(counts.values()) if counts else 0

            # Update batch record
            self.write({
                'last_pull_at': fields.Datetime.now(),
                'last_pull_summary': json.dumps(response, indent=2, ensure_ascii=False),
                'status': 'pulled',
                'last_error': False,
                'bridge_trace_id': trace_id[:255] if trace_id and len(trace_id) > 255 else trace_id,
            })

            # Post message to chatter
            summary_lines = [f"{et}: {count}" for et, count in sorted(counts.items())]
            message = f"Pulled from Notion successfully.\n\nTotal: {total_imported}\n\n" + "\n".join(summary_lines)
            if trace_id:
                message = f"{message}\n\nTrace ID: {trace_id}"

            self.message_post(body=message, subject='Pull Completed')

            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Pull Completed',
                    'message': f'Successfully pulled {total_imported} records from Notion.',
                    'type': 'success',
                    'sticky': False,
                }
            }

        except UserError:
            raise
        except Exception as e:
            error_msg = f"Failed to pull from Notion: {str(e)}"
            self._write_error(error_msg)
            _logger.exception(f"Error pulling from Notion for batch {self.id}")
            raise UserError(error_msg)

    # ========== Helper Methods ==========

    def _write_error(self, error_msg, trace_id=None):
        """Write error to last_error field.

        Handles dict/non-string types safely to avoid TypeError with +=.
        """
        # Ensure error_msg is string
        if isinstance(error_msg, dict):
            error_msg = json.dumps(error_msg, ensure_ascii=False, default=str)
        elif not isinstance(error_msg, str):
            error_msg = str(error_msg)

        full_error = error_msg

        # Ensure trace_id is string or None
        if trace_id:
            if isinstance(trace_id, dict):
                trace_id_str = json.dumps(trace_id, ensure_ascii=False, default=str)
            elif not isinstance(trace_id, str):
                trace_id_str = str(trace_id)
            else:
                trace_id_str = trace_id
            full_error = f"{full_error} [Trace: {trace_id_str}]"
            # Store only string in bridge_trace_id
            safe_trace_id = trace_id_str if len(trace_id_str) < 255 else trace_id_str[:252] + '...'
        else:
            safe_trace_id = False

        self.write({
            'last_error': full_error,
            'bridge_trace_id': safe_trace_id,
        })
        self.message_post(
            body=full_error,
            subject='Bridge API Error',
            message_type='notification'
        )

    def _safe_json(self, obj, limit=2000):
        """Safely serialize object to JSON string with limit."""
        try:
            result = json.dumps(obj, ensure_ascii=False, default=str)
            return self._mask_sensitive_fields(result[:limit])
        except Exception as e:
            return f"<JSON error: {str(e)}>"

    def _mask_sensitive_fields(self, text):
        """Mask sensitive information in text for logging."""
        if not text:
            return text

        # Mask patterns: token, secret, authorization, email, phone, etc.
        patterns = [
            (r'(?i)("(?:token|secret|authorization|auth)":\s*)"[^"]+"', r'\1"***MASKED***"'),
            (r'(?i)("(?:email|phone|tel)":\s*)"[^"]+"', r'\1"***MASKED***"'),
            (r'(?i)("(?:password|pwd|pass)":\s*)"[^"]+"', r'\1"***MASKED***"'),
            (r'(?i)("(?:api[_-]?key|apikey)":\s*)"[^"]+"', r'\1"***MASKED***"'),
        ]

        masked = text
        for pattern, replacement in patterns:
            masked = re.sub(pattern, replacement, masked)

        return masked

    def get_notion_page_urls_dict(self):
        """Parse notion_page_urls JSON text to dict."""
        self.ensure_one()
        if not self.notion_page_urls:
            return {}
        try:
            return json.loads(self.notion_page_urls)
        except (json.JSONDecodeError, TypeError):
            return {}

    def get_last_pull_summary_dict(self):
        """Parse last_pull_summary JSON text to dict."""
        self.ensure_one()
        if not self.last_pull_summary:
            return {}
        try:
            return json.loads(self.last_pull_summary)
        except (json.JSONDecodeError, TypeError):
            return {}
